"""
我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。

迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 'S' 表示），和唯一的宝藏地点（用 'T' 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 'M' 表示），只有所有机关均被触发，才可以拿到宝藏。

要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 'O' 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。

迷宫中同样有一些墙壁（用 '#' 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 '.' 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。

我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。

示例 1：

输入： ["S#O", "M..", "M.T"]

输出：16

解释：最优路线为： S->O, cost = 4, 去搬石头 O->第二行的M, cost = 3, M机关触发 第二行的M->O, cost = 3, 我们需要继续回去 O 搬石头。 O->第三行的M, cost = 4, 此时所有机关均触发 第三行的M->T, cost = 2，去T点拿宝藏。 总步数为16。 

示例 2：

输入： ["S#O", "M.#", "M.T"]

输出：-1

解释：我们无法搬到石头触发机关

示例 3：

输入： ["S#O", "M.T", "M.."]

输出：17

解释：注意终点也是可以通行的。

限制：

1 <= maze.length <= 100
1 <= maze[i].length <= 100
maze[i].length == maze[j].length
S 和 T 有且只有一个
0 <= M的数量 <= 16
0 <= O的数量 <= 40，题目保证当迷宫中存在 M 时，一定存在至少一个 O 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/xun-bao
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""


from typing import List
from collections import deque
from functools import lru_cache
class Solution:
    """
    TLE
    """
    def minimalSteps(self, maze: List[str]) -> int:
        def neighbors(i, j):
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < row and 0 <= nj < col and maze[ni][nj] != '#':
                    yield ni, nj

        @lru_cache(None)
        def bfs(p, q):
            pi, pj = divmod(p, col)
            qi, qj = divmod(q, col)
            visited = set()
            dq = deque([(pi, pj, 0)])
            visited.add((pi, pj))
            while dq:
                i, j, steps = dq.popleft()
                if (i, j) == (qi, qj):
                    return steps
                steps += 1
                for ni, nj in neighbors(i, j):
                    if (ni, nj) not in visited:
                        visited.add((ni, nj))
                        dq.append((ni, nj, steps))
            return float('inf')

        @lru_cache(None)
        def dp(p, q, m_tuple, stone):
            # print(p, q, m_tuple, stone)
            if not m_tuple:
                return bfs(p, q)
            res = float('inf')
            # m2 = list(m_tuple)
            if stone:
                for i in range(len(m_tuple)):
                    m2_tuple = tuple(m_tuple[:i] + m_tuple[i + 1:])
                    tmp = bfs(p, m_tuple[i]) + dp(m_tuple[i], q, m2_tuple, 0)
                    res = min(res, tmp)
            else:
                for o in o_list:
                    res = min(res, bfs(p, o) + dp(o, q, m_tuple, 1))
            return res

        m_list, o_list = [], []
        start, target = None, None
        row, col = len(maze), len(maze[0])
        for i in range(row):
            for j in range(col):
                ch = maze[i][j]
                idx = i * col + j
                if ch == 'M':
                    m_list.append(idx)
                elif ch == 'S':
                    start = idx
                elif ch == 'T':
                    target = idx
                elif ch == 'O':
                    o_list.append(idx)
        res = dp(start, target, tuple(m_list), 0)
        return res if res != float('inf') else -1


# 作者：Firepaw
# 链接：https://leetcode-cn.com/problems/xun-bao/solution/bi-jiao-jian-duan-de-python3-by-firepaw/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
from functools import lru_cache
class Solution:
    def minimalSteps(self, maze: List[str]) -> int:
        N, M = len(maze), len(maze[0])
        sx, sy, ex, ey = -1, -1, -1, -1
        traps = []
        stones = []
        for r in range(N):
            for c in range(M):
                if maze[r][c] == 'S':
                    sx, sy = r, c
                if maze[r][c] == 'T':
                    ex, ey = r, c
                if maze[r][c] == 'M':
                    traps.append((r, c))
                if maze[r][c] == 'O':
                    stones.append((r, c))
        
        numtrap = len(traps)
        
        # start to O
        # O to M
        # M to O
        # M to end
        INF = 10 ** 9 + 7
        
        def spfa(r, c):
            dist = [[INF for _ in range(M)] for _ in range(N)]
            q = collections.deque([(r, c)])
            dist[r][c] = 0
            while q:
                x, y = q.popleft()
                for nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:
                    if 0 <= nx < N and 0 <= ny < M and maze[nx][ny] != '#' and dist[nx][ny] > dist[x][y] + 1:
                        dist[nx][ny] = dist[x][y] + 1
                        q.append((nx, ny))
                        
            return dist
        
        diststart = spfa(sx, sy)
        
        if numtrap <= 0:
            return diststart[ex][ey] if diststart[ex][ey] < INF else -1
        
        disttrap = [spfa(r, c) for r, c in traps]
            
        distintrap = [[INF for _ in range(numtrap)] for _ in range(numtrap)]
        for ia in range(numtrap):
            for ib in range(ia+1, numtrap):
                distintrap[ia][ib] = min(disttrap[ia][r][c] + disttrap[ib][r][c] for r, c in stones)
                distintrap[ib][ia] = distintrap[ia][ib]
                
        @lru_cache(maxsize=None)
        def dfs(index, state, done):
            if done == 1:
                return min([diststart[r][c] + disttrap[index][r][c] for r, c in stones])
            
            prestate = state ^ (1 << index)
            return min(dfs(i, prestate, done-1) + distintrap[i][index] for i in range(numtrap) if i != index and (state & (1 << i) > 0))

        ans = min(dfs(i, (1 << numtrap) - 1, numtrap) + disttrap[i][ex][ey] for i in range(numtrap))
        return ans if ans < INF else -1


# 作者：li-bo-8
# 链接：https://leetcode-cn.com/problems/xun-bao/solution/python3-bfsdpzhuang-tai-ya-suo-by-li-bo-8/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
from queue import Queue
class Solution:
    def minimalSteps(self, maze: List[str]) -> int:
        # 四个方向
        dd = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        # 计算（x, y）到maze中其他点的距离，结果保存在ret中
        def bfs(x, y, maze, m, n):
            ret = [[-1]*n for _ in range(m)]
            ret[x][y] = 0
            q = Queue()
            q.put((x,y))
            while q.qsize():
                curx, cury = q.get()
                for dx, dy in dd:
                    nx = curx + dx
                    ny = cury + dy
                    if 0 <= nx < m and 0 <= ny < n and maze[nx][ny] != '#' and ret[nx][ny] == -1:
                        ret[nx][ny] = ret[curx][cury] + 1
                        q.put((nx, ny))
            return ret

        m = len(maze)
        n = len(maze[0])

        startX = -1
        startY = -1
        endX = -1
        endY = -1

        # 机关 & 石头
        buttons = []
        stones = []

        # 记录所有特殊信息的位置
        for i in range(m):
            for j in range(n):
                if maze[i][j] == 'S':
                    startX = i
                    startY = j
                elif maze[i][j] == 'T':
                    endX = i
                    endY = j
                elif maze[i][j] == 'O':
                    stones.append((i,j))
                elif maze[i][j] == 'M':
                    buttons.append((i,j))
                else:
                    pass
        
        nb = len(buttons)
        ns = len(stones)

        startToAnyPos = bfs(startX, startY, maze, m, n)

        # 若没有机关，最短距离就是(startX, startY)到(endX, endY)的距离
        if nb == 0:
            return startToAnyPos[endX][endY]

        # 记录第i个机关到第j个机关的最短距离
        # dist[i][nb]表示到起点的距离， dist[i][nb+1]表示到终点的距离
        dist = [[-1]*(nb+2) for _ in range(nb)]

        # 遍历所有机关，计算其和其他点的距离
        buttonsToAnyPos = []
        for i in range(nb):
            bx, by = buttons[i]
            # 记录第i个机关到其他点的距离
            iToAnyPos = bfs(bx, by, maze, m, n)
            buttonsToAnyPos.append(iToAnyPos)
            # 第i个机关到终点的距离就是(bx, by)到(endX, endY)的距离
            dist[i][nb + 1] = iToAnyPos[endX][endY]
        
        for i in range(nb):
            # 计算第i个机关到(startX, startY)的距离
            # 即从第i个机关出发，通过每个石头(sx, sy)，到(startX, startY)的最短距离
            tmp = -1
            for j in range(ns):
                sx, sy = stones[j]
                if buttonsToAnyPos[i][sx][sy] != -1 and startToAnyPos[sx][sy] != -1:
                    if tmp == -1 or tmp > buttonsToAnyPos[i][sx][sy] + startToAnyPos[sx][sy]:
                        tmp = buttonsToAnyPos[i][sx][sy] + startToAnyPos[sx][sy]

            dist[i][nb] = tmp

            # 计算第i个机关到第j个机关的距离
            # 即从第i个机关出发，通过每个石头(sx, sy)，到第j个机关的最短距离
            for j in range(i+1, nb):
                mn = -1
                for k in range(ns):
                    sx, sy = stones[k]
                    if buttonsToAnyPos[i][sx][sy] != -1 and buttonsToAnyPos[j][sx][sy] != -1:
                        if mn == -1 or mn > buttonsToAnyPos[i][sx][sy] + buttonsToAnyPos[j][sx][sy]:
                            mn = buttonsToAnyPos[i][sx][sy] + buttonsToAnyPos[j][sx][sy]
                # 距离是无向图，对称的
                dist[i][j] = mn
                dist[j][i] = mn
        
        # 若有任意一个机关 到起点或终点没有路径(即为-1),则说明无法达成，返回-1
        for i in range(nb):
            if dist[i][nb] == -1 or dist[i][nb+1] == -1:
                return -1
        
        # dp数组， -1代表没有遍历到, 1<<nb表示题解中提到的mask, dp[mask][j]表示当前处于第j个机关，总的触发状态为mask所需要的最短路径, 由于有2**nb个状态，因此1<<nb的开销必不可少
        dp = [[-1]*nb for _ in range(1 << nb)]
        # 初识状态，即从start到第i个机关，此时mask的第i位为1，其余位为0
        for i in range(nb):
            dp[1 << i][i] = dist[i][nb]
        
        # 二进制中数字大的mask的状态肯定比数字小的mask的状态多，所以直接从小到大遍历更新即可
        for mask in range(1, (1 << nb)):
            for i in range(nb):
                # 若当前位置是正确的，即mask的第i位是1
                if mask & (1 << i) != 0:
                    for j in range(nb):
                        # 选择下一个机关j,要使得机关j目前没有到达，即mask的第j位是0
                        if mask & (1 << j) == 0:
                            nextMask = mask | (1 << j)
                            if dp[nextMask][j] == -1 or dp[nextMask][j] > dp[mask][i] + dist[i][j]:
                                dp[nextMask][j] = dp[mask][i] + dist[i][j]

        # 最后一个机关到终点
        ans = -1
        finalMask = (1 << nb) - 1
        for i in range(nb):
            if ans == -1 or ans > dp[finalMask][i] + dist[i][nb + 1]:
                ans = dp[finalMask][i] + dist[i][nb + 1]
        return ans



from typing import List
from collections import deque, defaultdict
from functools import lru_cache
from itertools import combinations
class Solution:
    def minimalSteps(self, maze: List[str]) -> int:
        def neighbors(p):
            i, j = divmod(p, col)
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < row and 0 <= nj < col and maze[ni][nj] != '#':
                    yield ni * col + nj

        @lru_cache(None)
        def bfs(p):
            """
            store the distance from p to other location in maze
            """
            visited = set()
            dq = deque([(p, 0)])
            visited.add(p)
            while dq:
                tmp, steps = dq.popleft()
                dist[(p, tmp)] = steps
                dist[(tmp, p)] = steps
                steps += 1
                for np in neighbors(tmp):
                    if np not in visited:
                        visited.add(np)
                        dq.append((np, steps))

        @lru_cache(None)
        def dp(p, q, m_tuple):
            """
            the min distance from p to q, carry a stone
            """
            if not m_tuple:
                return dist[(p, q)]
            res = float('inf')
            for i in range(len(m_tuple)):
                m2_tuple = tuple(m_tuple[:i] + m_tuple[i + 1:])
                tmp = dist_o[(p, m_tuple[i])] + dp(m_tuple[i], q, m2_tuple)
                res = min(res, tmp)
            return res

        m_list, o_list = [], []
        start, target = None, None
        dist = defaultdict(lambda: float('inf'))
        dist_o = defaultdict(lambda: float('inf'))
        row, col = len(maze), len(maze[0])
        for i in range(row):
            for j in range(col):
                ch = maze[i][j]
                idx = i * col + j
                if ch == 'M':
                    m_list.append(idx)
                elif ch == 'S':
                    start = idx
                elif ch == 'T':
                    target = idx
                elif ch == 'O':
                    o_list.append(idx)

        bfs(start)
        for o in o_list:
            bfs(o)
        for m in m_list:
            bfs(m)
        location = [start] + m_list
        for o in o_list:
            for p, q in combinations(location, 2):
                dist_o[(p, q)] = min(dist_o[(p, q)], dist[(p, o)] + dist[(q, o)])
                dist_o[(q, p)] = dist_o[(p, q)]

        res = dp(start, target, tuple(m_list))
        return res if res != float('inf') else -1


from typing import List
from collections import deque, defaultdict
from functools import lru_cache
from itertools import combinations
class Solution:
    def minimalSteps(self, maze: List[str]) -> int:
        def neighbors(p):
            i, j = divmod(p, col)
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < row and 0 <= nj < col and maze[ni][nj] != '#':
                    yield ni * col + nj

        @lru_cache(None)
        def bfs(p):
            """
            store the distance from p to other location in maze
            """
            visited = set()
            dq = deque([(p, 0)])
            visited.add(p)
            while dq:
                tmp, steps = dq.popleft()
                dist[(p, tmp)] = steps
                dist[(tmp, p)] = steps
                steps += 1
                for np in neighbors(tmp):
                    if np not in visited:
                        visited.add(np)
                        dq.append((np, steps))

        @lru_cache(None)
        def dp(p, q, status):
            """
            the min distance from p to q, carry a stone
            """
            if status == target:
                return dist[(p, q)]
            res = float('inf')
            for i in range(len_m):
                if (1 << i) & status == 0:
                    tmp = dist_o[(p, m_list[i])] + dp(m_list[i], q, (1 << i) | status)
                    res = min(res, tmp)
            return res

        m_list, o_list = [], []
        start, end = None, None
        dist = defaultdict(lambda: float('inf'))
        dist_o = defaultdict(lambda: float('inf'))
        row, col = len(maze), len(maze[0])
        for i in range(row):
            for j in range(col):
                ch = maze[i][j]
                idx = i * col + j
                if ch == 'M':
                    m_list.append(idx)
                elif ch == 'S':
                    start = idx
                elif ch == 'T':
                    end = idx
                elif ch == 'O':
                    o_list.append(idx)

        bfs(start)
        for o in o_list:
            bfs(o)
        for m in m_list:
            bfs(m)
        location = [start] + m_list
        for o in o_list:
            for p, q in combinations(location, 2):
                dist_o[(p, q)] = min(dist_o[(p, q)], dist[(p, o)] + dist[(q, o)])
                dist_o[(q, p)] = dist_o[(p, q)]

        len_m = len(m_list)
        target = (1 << len_m) - 1
        res = dp(start, end, 0)
        return res if res != float('inf') else -1

S = Solution()
maze = ["S#O", "M..", "M.T"]
print(S.minimalSteps(maze))
maze = ["S#O", "M.#", "M.T"]
print(S.minimalSteps(maze))
maze = ["S#O", "M.T", "M.."]
print(S.minimalSteps(maze))
maze = ["...#............#.....#.#.#...###...................#....#.........#...##........#..................","...O......##..............#......#.........#...........#...#....#.........#.........................","..#.#.........#....#........##..............#...................#........O.#...#.........#....#.....",".....#......#..#.#..#........##...........#.....#..................#........#....#..#...............",".#........................#...#...#..#..................................#........#.....#............",".........##......#........##.......#....................#..........O...........#.#.#......#........#","......#....#.......#.......#..#..................#.#............#............#..............#.......","............#..#......#.........#........#......#......#....#.............................#.........","#.#.##....................#...................................#...............#..#..#............#..","..................................................##.#........#...#..................#......#O.....#","#.............M................#..#.......................##.....#..........#..............#.#......","O....#.....#............#...##..........#.......#......#...................#........#...............","O.........................#.#....#..#............................#..........#.......#..........#....",".....O.........#.#..........#..........#.................#........##............#....#.......#......","#......#....#..............#....#............#............#.#.#....#................................","............##..#.....................#.......##..#.#.#........................................#....","...........#.......#...#..#............##..#.........#..#..#..#.........#..#.....#...........##.....","........#......#..#.#...O.....#....#....#............#..........#......#.....................#......","..#.....#..........#....##.#.....................#.#............##...#........##..........#O...#....","........#....#.#..........#..#..................................#..#....#...#.....#.....#.........#.",".#.........#.....................#..#.....#............#.....#.#.........#.......................#..",".....#............................#......##....#....................................#.#........#..#.",".#....#.#.........#............#.......................#.......................#.........#......#...",".......#..........#......................#..#..........#......O.......#..#....#...........O.........",".#O........M....#.##......O.....#......#.#..#...........#..#...#..#..............................#..","....................O...M..........#..........#...#.........#.............#...........#.#...........","#...#.#.....#........#......#.....#...........#...............#.##.....................#..#.........",".....#................#...................##.......#..#.............##...#..#.......................",".....##..........................##............#.............#..........#.#..................#......",".#.....................##.#......#.#.#..........#.#....#................#........#......#...#...#..#",".........#..........#.........O..............#.....M.................#.....#....#...................","...........#......#......##..........#....#.....#..........M...........#....#....##.......#.........","##...................................................#.....#.......##.#.............................","..........#........##..........#..................#......M.#.#.#.........#..........................","....#..#..M#.....M.....#..........M...........#.#............................#......................","..#......#..........#......#..#...##..................#..#...#...................#.......#...#..###.","..................#..#.#.................T..................#.............#..................#......","........#.#...#............#.................#...##.#......#..............#.........................","....#.............#.##.#.........#..##......#.#.#..................................................#","..#.......#.............#.#....#.#.......................#.....#..........#................#........","....#.......................#....#.............#....#....#..........##........#..............#......","#..................#.....O................#....#.#......#.........#......#......................#...","..........#...........#.......O.......##...........#.....................#.........................#","..#................................#.............................#.........#...........#............","..........#.....#.......#..................#............#.........#...#.........O.....#.............","#...#.............#....#........#......#..#........#..........#.............................#.#.....",".......#..........#........O#....#...#.........#...........................................#........",".....##.....#...#..#..#...#....................#......#..#......#...##......O.........#....##.......","................#.....#.........#.............................O.......#............................#",".........#.#.................#.....#....#.........#....#............................................","...#.#...........................#.......#......#............#.#......................###.....O..#..","...................#.#.#......#.......#...............................#......#....#....#............","#.#......#....#........#.#..#.#..........##...##.................#..........#.....................#.",".#....#.......................................#.....#..........#.....M#..........#.....#............","........#.....................#.#............#...............#.#..O.......#...................#.....","....#............................#.......#....#.................................................#...","..................#.#.......#..........#.....#.......#..............#...............#...............",".........................##.........#......#...............#.O..................##............#.....","..##......#..#........#.....................#....#......#.................#...........##.......#....","#..#..#............###..#...............#....#........#..........#..#...........#...............#O..","#..............................#...............#.#....#..#..#..#......#.......#.##............#.....","#.......S.......##.....#...........................###.#...........................#.#............#.",".................................#...........#...........#..........#.....#..#.#...#............#...","...........#....##.....#.............#..#...................................##....................#.","M.#....................#.#...O...............................M......O..................#....#.......","....M#.####........#......................................................#........#................","......#.#..................#................................................##....#.................","...#.............................................###..#...#........................#..#.......#.#...","........#.............O#..#.#....................#..#..#..........#....#.....#......#...#.......#...",".#..##..................#........#..........#........#....#.........##O...............#.....#.......","#.....#.#.#........#.......##....................#..........#.............#...#...#....##........#.#","................#.........#...........#.....#.......##....#..............#..........................","......O........#................##......#.#..................#.........#.............##.............",".#....#.#.........#...#...............#...........##.....#...........#..........M....#............#.","..............#...............O.......#......................#....................#...O..#..........","................#...#.#...#....................#.......#...#..............O.........................",".#................................##.............#...#.#.....#.#................#..#...#............",".....#..............#...............#...............................................................",".......................#....................##..#................#......................#..#.....#..",".........#..#....................#.............#..#......................#.......#..................","#..#........#....................................#.....#..............#..........#......#.#.......#.",".#......................#.....#......#........#....#...#......O#....#.........#....##...............","...........................#.....#...#.........#..#......#.....M......#....#...#............##...O##",".......................#...##............#.........#..............#....#....#..#...#.....#.#........",".#....#.......................#.....#O...#.............................#............#...............","...#.#..............#....M..............#.#.......#...#...#...#..........#........................##",".....#................#.#........#......#....................#.....#................................","....O.....#..................#.#..O...#.........#.......#.#..............#.....#.............#....#.",".......#..#.#..##......#...................#...............#.#.......#.........#....#......#..#....#",".....#.............#...#.......#.#.#........##.....#.#.....#....#......#.#...#................#.....","...............#..........#.#.##...................#.......................#.......##.....#..#.#....",".................#......#............................#...#...##........................#............","#........#........#..........#...#........#.#..#..............#...#.#.....#.#.#.#...................",".........#.#.......###.......#..........#.......#..........................................#........",".#..................#.....#......##.#...........#..........#.....#..................#............#.#","..................................................#.........#..#.#.....##....#...........#..........","......#...........#......#.......#...#.....................#.#............##................#....#..",".#..........................#........#........#.......#........#...#...........###...........#......","#...#...#.......#...................................##........O.........#.....#......#...#..........","#.......#.....#.#....#...#................O...................#..................#.......##........."]
print(S.minimalSteps(maze))