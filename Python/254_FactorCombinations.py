"""
Numbers can be regarded as product of its factors. For example,

8 = 2 x 2 x 2;
  = 2 x 4.
Write a function that takes an integer n and return all possible combinations of its factors.

Note:

You may assume that n is always positive.
Factors should be greater than 1 and less than n.
Example 1:

Input: 1
Output: []
Example 2:

Input: 37
Output:[]
Example 3:

Input: 12
Output:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]
Example 4:

Input: 32
Output:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/factor-combinations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""



class Solution:
    def getFactors(self, n: int):
        def genFactors(n):
            i = 2
            res = set()
            while i * i <= n:
                if n % i == 0:
                    k = n//i
                    res.add((i, k))
                    lst = genFactors(k)
                    for j in lst:
                        res.add(tuple(sorted([i] + list(j)))) 
                i += 1
            return res

        return [list(s) for s in list(genFactors(n))]


class Solution:
    def getFactors(self, n):
        self.res = []
        self.backtrack(n, 2, [])
        return self.res

    def backtrack(self, n, index, cur):
        for i in range(index, int(n ** 0.5) + 1):
            if n % i == 0:
                self.res.append(sorted(cur + [n // i, i]))
                self.backtrack(n // i, i, [i] + cur)


import math
class Solution:
    def getFactors(self, n: int):
        def f(k: int, st: int):
            res = []
            for i in range(st, int(math.sqrt(k)) + 1): # the factors in (2, st) will be generated by f(k, 2), so no missing and no overlapping
                if k % i == 0:
                    t = f(k // i, i)
                    t.append([k // i])
                    res.extend([[i] + x for x in t])
            print(k, st, res)
            return res

        return f(n, 2)
# 因式分解有可能重复的情况下，选定一个方向，就可以避免重复。
# dfs(num)
# 遍历数字1~num，找到能被自己整除的因子mulNum，那么[mulNum, num/mulNum]就是一种结果， 并往下继续dfs(num/mulNum)得到num/mulNum的可能情况并添加到返回结果。

# 剪枝点：

# 为了避免重复，没必要从1开始遍历，而是从上一次的mulNum开始遍历，这样保证mulNum后续dfs的过程是递增的，所以不会出现重复。
# 遍历终点没必要为num， 而是num的开根号， 因此最大情况2^32的开根号结果为2^16次方=65536，是可接受范围。


# 作者：mnm135
# 链接：https://leetcode-cn.com/problems/factor-combinations/solution/ping-lun-qu-de-shuang-bai-fang-fa-mei-ci-tian-jia-/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

S = Solution()
print(S.getFactors(12))
print(S.getFactors(32))
# print(S.getFactors(64))

# 输出：
# [[2,2,2,2,4],[2,2,4,4],[4,16],[8,8],[2,4,8],[2,2,2,2,2,2],[2,32],[2,2,2,8],[2,2,16]]
# 预期结果：
# [[2,32],[4,16],[2,2,16],[8,8],[2,4,8],[2,2,2,8],[4,4,4],[2,2,4,4],[2,2,2,2,4],[2,2,2,2,2,2]]